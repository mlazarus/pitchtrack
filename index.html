<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pitch Game Tracker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: 'Manrope', 'Segoe UI', system-ui, sans-serif;
      }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
      const { useState, useEffect } = React;
      const { createClient } = supabase;

      const supabaseClient = createClient(
        'https://lhlnjggrljdgmytmoaqb.supabase.co',
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxobG5qZ2dybGpkZ215dG1vYXFiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgzMjUwNjAsImV4cCI6MjA4MzkwMTA2MH0.61TrFDb3XD14y26_aOhMqcrmgORDnrB7OmRdGlABgKI'
      );

      // Toast notification component
      const Toast = ({ message, show }) => {
        return (
          <div
            style={{
              position: 'fixed',
              bottom: '2rem',
              right: '2rem',
              background: 'white',
              padding: '1rem 1.5rem',
              borderRadius: '8px',
              boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
              display: show ? 'block' : 'none',
              zIndex: 3000
            }}
          >
            {message}
          </div>
        );
      };

      // Modal component
      const Modal = ({ show, onClose, children }) => {
        if (!show) return null;

        return (
          <div
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0,0,0,0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 2000
            }}
            onClick={onClose}
          >
            <div
              style={{
                background: 'white',
                borderRadius: '12px',
                padding: '2rem',
                maxWidth: '500px',
                width: '90%',
                maxHeight: '80vh',
                overflowY: 'auto'
              }}
              onClick={(e) => e.stopPropagation()}
            >
              {children}
            </div>
          </div>
        );
      };

      // Helper functions for consistent styling
      const buttonStyle = (bgColor) => ({
        padding: '0.75rem 1.5rem',
        border: 'none',
        borderRadius: '8px',
        fontSize: '1rem',
        fontWeight: '700',
        cursor: 'pointer',
        background: bgColor,
        color: 'white',
        transition: 'all 0.2s'
      });

      const inputStyle = {
        width: '100%',
        padding: '0.75rem',
        border: '2px solid #334155',
        borderRadius: '8px',
        background: '#0f172a',
        color: '#e8edf5',
        fontSize: '1rem'
      };

      // Main App Component
      function PitchGameTracker() {
        const [currentTable, setCurrentTable] = useState(1);
        const [players, setPlayers] = useState([]);
        const [teamA, setTeamA] = useState([]);
        const [teamB, setTeamB] = useState([]);
        const [dealers, setDealers] = useState([]);
        const [hands, setHands] = useState([]);
        const [gameNumber, setGameNumber] = useState(1);
        const [currentGameId, setCurrentGameId] = useState(null);
        const [completedGames, setCompletedGames] = useState([]);
        const [setHistory, setSetHistory] = useState([]); // Filtered by session for Game tab
        const [allSets, setAllSets] = useState([]); // Unfiltered for Stats/Leaderboard tabs
        const [currentSetGames, setCurrentSetGames] = useState([]);
        const [sessionEndedAt, setSessionEndedAt] = useState(null);
        const [stakes, setStakes] = useState({ gameScore: 4, bump: 2, points: 1, bonus: 25, tableFontSize: 0.9 });
        const [activeTab, setActiveTab] = useState('game');
        
        // Date filters
        const today = new Date();
        const yearStart = new Date(today.getFullYear(), 0, 1);
        const [leaderboardStartDate, setLeaderboardStartDate] = useState(yearStart.toISOString().split('T')[0]);
        const [leaderboardEndDate, setLeaderboardEndDate] = useState(today.toISOString().split('T')[0]);
        const [statsStartDate, setStatsStartDate] = useState(yearStart.toISOString().split('T')[0]);
        const [statsEndDate, setStatsEndDate] = useState(today.toISOString().split('T')[0]);
        const [leaderboardSets, setLeaderboardSets] = useState([]);
        const [statsSets, setStatsSets] = useState([]);
        
        // Modal states
        const [showScoreModal, setShowScoreModal] = useState(false);
        const [showDealerModal, setShowDealerModal] = useState(false);
        const [showEndGameModal, setShowEndGameModal] = useState(false);
        const [showEndSessionModal, setShowEndSessionModal] = useState(false);
        const [showEndSetModal, setShowEndSetModal] = useState(false);
        const [scoreA, setScoreA] = useState('');
        const [scoreB, setScoreB] = useState('');
        const [tempDealers, setTempDealers] = useState([]);
        const [editingHandIndex, setEditingHandIndex] = useState(null);
        const [newPlayerName, setNewPlayerName] = useState('');
        
        // Toast
        const [toast, setToast] = useState({ show: false, message: '' });

        const showToast = (message) => {
          setToast({ show: true, message });
          setTimeout(() => setToast({ show: false, message: '' }), 2000);
        };

        // Load initial data
        useEffect(() => {
          loadData();
        }, [currentTable]);

        useEffect(() => {
          // Fetch leaderboard data when dates change
          const fetchLeaderboardData = async () => {
            try {
              console.log('Fetching leaderboard data for:', leaderboardStartDate, 'to', leaderboardEndDate);
              const start = new Date(leaderboardStartDate + 'T00:00:00').toISOString();
              const end = new Date(leaderboardEndDate + 'T23:59:59').toISOString();
              console.log('ISO dates:', start, 'to', end);
              
              const { data: sets, error } = await supabaseClient
                .from('sets')
                .select('*')
                .gte('completed_at', start)
                .lte('completed_at', end)
                .order('completed_at', { ascending: false });

              if (error) {
                console.error('Error fetching leaderboard sets:', error);
                setLeaderboardSets([]);
                return;
              }

              console.log('Fetched sets count:', sets?.length || 0, 'sets:', sets);

              const mapped = sets?.map(s => ({
                teamA: s.team_a_players,
                teamB: s.team_b_players,
                teamAScore: parseFloat(s.team_a_score),
                teamBScore: parseFloat(s.team_b_score),
                completed_at: s.completed_at,
                table_number: s.table_number
              })) || [];
              
              console.log('Setting leaderboardSets to:', mapped);
              setLeaderboardSets(mapped);
            } catch (err) {
              console.error('Error:', err);
              setLeaderboardSets([]);
            }
          };
          fetchLeaderboardData();
        }, [leaderboardStartDate, leaderboardEndDate]);

        useEffect(() => {
          // Fetch stats data when dates change
          const fetchStatsData = async () => {
            try {
              const start = new Date(statsStartDate + 'T00:00:00').toISOString();
              const end = new Date(statsEndDate + 'T23:59:59').toISOString();
              
              const { data: sets, error } = await supabaseClient
                .from('sets')
                .select('*')
                .gte('completed_at', start)
                .lte('completed_at', end)
                .order('completed_at', { ascending: false });

              if (error) {
                console.error('Error fetching stats sets:', error);
                setStatsSets([]);
                return;
              }

              const mapped = sets?.map(s => ({
                teamA: s.team_a_players,
                teamB: s.team_b_players,
                teamAScore: parseFloat(s.team_a_score),
                teamBScore: parseFloat(s.team_b_score),
                completed_at: s.completed_at,
                table_number: s.table_number
              })) || [];
              
              setStatsSets(mapped);
            } catch (err) {
              console.error('Error:', err);
              setStatsSets([]);
            }
          };
          fetchStatsData();
        }, [statsStartDate, statsEndDate]);

        const loadData = async () => {
          console.log('ðŸ“¥ loadData called for table:', currentTable);
          try {
            // Load players
            const { data: playersData } = await supabaseClient
              .from('players')
              .select('*')
              .order('name');
            setPlayers(playersData?.map(p => p.name) || []);

            // Load stakes
            const { data: stakesData } = await supabaseClient
              .from('stakes')
              .select('*')
              .limit(1)
              .single();
            if (stakesData) {
              setStakes({
                gameScore: parseFloat(stakesData.game_score) || 4,
                bump: parseFloat(stakesData.bump) || 2,
                points: parseFloat(stakesData.points) || 1,
                bonus: parseFloat(stakesData.bonus) || 25,
                tableFontSize: parseFloat(stakesData.table_font_size) || 0.9
              });
            }

            // Load current game
            const { data: currentGame } = await supabaseClient
              .from('games')
              .select('*')
              .is('winner', null)
              .eq('table_number', currentTable)
              .order('created_at', { ascending: false })
              .limit(1);

            if (currentGame && currentGame.length > 0) {
              const game = currentGame[0];
              console.log('  âœ… Found existing game:', game.id, 'Game #' + game.game_number);
              setCurrentGameId(game.id);
              setGameNumber(game.game_number);
              setTeamA(game.team_a_players || []);
              setTeamB(game.team_b_players || []);

              // Load hands for this game
              const { data: handsData } = await supabaseClient
                .from('hands')
                .select('*')
                .eq('game_id', game.id)
                .order('hand_order');
              console.log('  âœ… Loaded', handsData?.length || 0, 'hands for game');
              setHands(handsData?.map(h => ({
                dealer: h.dealer,
                scoreA: parseFloat(h.score_a),
                scoreB: parseFloat(h.score_b)
              })) || []);
            } else {
              // Create new game
              console.log('  âš ï¸ No in-progress game found, creating new one');
              const { data: lastGame } = await supabaseClient
                .from('games')
                .select('game_number')
                .eq('table_number', currentTable)
                .order('game_number', { ascending: false })
                .limit(1);
              
              const num = lastGame && lastGame.length > 0 ? lastGame[0].game_number + 1 : 1;
              const { data: newGame } = await supabaseClient
                .from('games')
                .insert({
                  game_number: num,
                  table_number: currentTable,
                  team_a_players: teamA,
                  team_b_players: teamB
                })
                .select()
                .single();
              
              if (newGame) {
                setCurrentGameId(newGame.id);
                setGameNumber(newGame.game_number);
              }
            }

            // Load completed games
            const { data: completed } = await supabaseClient
              .from('games')
              .select('*')
              .not('winner', 'is', null)
              .eq('table_number', currentTable)
              .order('completed_at', { ascending: false })
              .limit(10);
            setCompletedGames(completed?.map(game => ({
              gameNumber: game.game_number,
              winner: game.winner,
              scoreA: parseFloat(game.score_a),
              scoreB: parseFloat(game.score_b),
              handsPlayed: game.hands_played,
              teamA: game.team_a_players,
              teamB: game.team_b_players
            })) || []);

            // Load set history
            const { data: sets } = await supabaseClient
              .from('sets')
              .select('*')
              .eq('table_number', currentTable)
              .order('completed_at', { ascending: false });
            
            const mappedSets = sets?.map(s => ({
              teamA: s.team_a_players,
              teamB: s.team_b_players,
              teamAScore: parseFloat(s.team_a_score),
              teamBScore: parseFloat(s.team_b_score),
              completed_at: s.completed_at
            })) || [];
            
            // Store all sets for Stats/Leaderboard tabs
            setAllSets(mappedSets);
            
            // Get sessionEndedAt from localStorage
            const storedSessionEnd = localStorage.getItem(`sessionEnd_table${currentTable}`);
            const sessionEnd = storedSessionEnd ? new Date(storedSessionEnd) : null;
            
            // Filter for Game tab view (only sets after session was ended)
            const filteredSets = mappedSets.filter(s => {
              if (!sessionEnd) return true; // No session end, show all
              const setDate = new Date(s.completed_at);
              return setDate > sessionEnd; // Only show sets after session was ended
            });
            
            setSetHistory(filteredSets);
          } catch (error) {
            console.error('Error loading data:', error);
          }
        };

        const toggleTeam = async (player) => {
          const inA = teamA.includes(player);
          const inB = teamB.includes(player);

          let newTeamA = [...teamA];
          let newTeamB = [...teamB];

          if (!inA && !inB) {
            if (teamA.length >= 3) {
              showToast('Team A full');
              return;
            }
            newTeamA.push(player);
            showToast(`${player} â†’ A`);
          } else if (inA) {
            if (teamB.length >= 3) {
              showToast('Team B full');
              return;
            }
            newTeamA = newTeamA.filter(p => p !== player);
            newTeamB.push(player);
            showToast(`${player} â†’ B`);
          } else {
            newTeamB = newTeamB.filter(p => p !== player);
            showToast(`${player} removed`);
          }

          setTeamA(newTeamA);
          setTeamB(newTeamB);

          if (currentGameId) {
            await supabaseClient
              .from('games')
              .update({ team_a_players: newTeamA, team_b_players: newTeamB })
              .eq('id', currentGameId);
          }
        };

        const addPlayer = async () => {
          const name = newPlayerName.trim();
          if (!name) {
            showToast('Enter name');
            return;
          }
          if (players.includes(name)) {
            showToast('Player exists');
            return;
          }

          const { error } = await supabaseClient.from('players').insert({ name });
          if (error) {
            showToast('Error: ' + error.message);
            return;
          }

          setPlayers([...players, name]);
          setNewPlayerName('');
          showToast(`${name} added!`);
        };

        const openScoreModal = () => {
          console.log('ðŸŽ¯ openScoreModal called');
          console.log('  - currentGameId:', currentGameId);
          console.log('  - hands.length:', hands.length);
          console.log('  - dealers:', dealers);
          
          if (dealers.length === 0) {
            if (window.confirm('Dealers not set! Would you like to select dealers now?')) {
              setShowDealerModal(true);
            }
            return;
          }
          setScoreA('');
          setScoreB('');
          setEditingHandIndex(null);
          setShowScoreModal(true);
          console.log('  âœ… Score modal opened');
        };

        const editHand = (index) => {
          setEditingHandIndex(index);
          setScoreA(hands[index].scoreA.toString());
          setScoreB(hands[index].scoreB.toString());
          setShowScoreModal(true);
        };

        const confirmScore = async () => {
          console.log('ðŸ“ confirmScore called');
          console.log('  - currentGameId:', currentGameId);
          console.log('  - dealers:', dealers);
          console.log('  - hands.length:', hands.length);
          console.log('  - scoreA:', scoreA, 'scoreB:', scoreB);
          
          const sA = scoreA.trim() === '' ? 0 : parseFloat(scoreA);
          const sB = scoreB.trim() === '' ? 0 : parseFloat(scoreB);

          if (isNaN(sA) || isNaN(sB)) {
            showToast('Enter valid scores');
            return;
          }

          if (scoreA.trim() === '' && scoreB.trim() === '') {
            showToast('At least one team must have a score');
            return;
          }

          if (editingHandIndex !== null) {
            // Edit existing hand
            console.log('  - Editing hand at index:', editingHandIndex);
            await supabaseClient
              .from('hands')
              .update({ score_a: sA, score_b: sB })
              .eq('game_id', currentGameId)
              .eq('hand_order', editingHandIndex);

            const newHands = [...hands];
            newHands[editingHandIndex] = { ...newHands[editingHandIndex], scoreA: sA, scoreB: sB };
            setHands(newHands);
            showToast('Hand updated');
            console.log('  âœ… Hand updated');
          } else {
            // Add new hand
            const dealer = dealers[hands.length % dealers.length];
            console.log('  - Adding new hand, dealer:', dealer);
            console.log('  - Inserting to database...');
            
            const { data, error } = await supabaseClient.from('hands').insert({
              game_id: currentGameId,
              dealer,
              score_a: sA,
              score_b: sB,
              hand_order: hands.length
            }).select();
            
            if (error) {
              console.error('  âŒ Database error:', error);
              showToast('Error saving hand: ' + error.message);
              return;
            }
            
            console.log('  âœ… Hand saved to database:', data);
            
            const newHand = { dealer, scoreA: sA, scoreB: sB };
            console.log('  - Setting hands state, new hand:', newHand);
            console.log('  - Current hands before update:', hands);
            
            // Use functional update to avoid stale closure
            setHands(prevHands => {
              const updated = [...prevHands, newHand];
              console.log('  - Functional update: prevHands.length =', prevHands.length, 'â†’ updated.length =', updated.length);
              return updated;
            });
            
            showToast('Score added!');
            console.log('  âœ… Hands state update queued');
            
            // Reload hands from database to ensure we're in sync
            console.log('  ðŸ”„ Reloading hands from database for game:', currentGameId);
            const { data: reloadedHands, error: reloadError } = await supabaseClient
              .from('hands')
              .select('*')
              .eq('game_id', currentGameId)
              .order('hand_order');
            
            if (reloadError) {
              console.error('  âŒ Error reloading hands:', reloadError);
            } else if (reloadedHands) {
              const mappedHands = reloadedHands.map(h => ({
                dealer: h.dealer,
                scoreA: parseFloat(h.score_a),
                scoreB: parseFloat(h.score_b)
              }));
              console.log('  âœ… Reloaded', mappedHands.length, 'hands from database');
              setHands(mappedHands);
            } else {
              console.log('  âš ï¸ reloadedHands is null/undefined');
            }
          }

          setScoreA(''); // Clear for next hand
          setScoreB(''); // Clear for next hand
          setEditingHandIndex(null); // Clear editing state
          setShowScoreModal(false);
          console.log('  âœ… confirmScore complete');
        };

        const openDealerModal = () => {
          const allPlayers = [...teamA, ...teamB];
          if (allPlayers.length < 4) {
            showToast('Need 4+ players');
            return;
          }
          setTempDealers([]);
          setShowDealerModal(true);
        };

        const toggleDealer = (player) => {
          if (tempDealers.includes(player)) {
            setTempDealers(tempDealers.filter(d => d !== player));
          } else {
            if (tempDealers.length >= 4) {
              showToast('Maximum 4 dealers');
              return;
            }
            setTempDealers([...tempDealers, player]);
          }
        };

        const confirmDealers = () => {
          if (tempDealers.length !== 4) {
            showToast('Please select exactly 4 dealers');
            return;
          }
          setDealers([...tempDealers]);
          setShowDealerModal(false);
          showToast('Dealers set: ' + tempDealers.join(', '));
        };

        const resetDealers = () => {
          if (dealers.length === 0) {
            showToast('No dealers');
            return;
          }
          if (window.confirm('Reset dealers?')) {
            setDealers([]);
            showToast('Dealers reset!');
          }
        };

        const calcScore = (winner) => {
          const tot = { a: 0, b: 0 };
          hands.forEach(h => {
            tot.a += h.scoreA;
            tot.b += h.scoreB;
          });

          let bA = 0, bB = 0;
          hands.forEach(h => {
            if (h.scoreA < 0) bA++;
            if (h.scoreB < 0) bB++;
          });

          const last = hands[hands.length - 1];
          const gA = last ? last.scoreA : 0;
          const gB = last ? last.scoreB : 0;
          let fA = 0, fB = 0;

          if (winner === 'A') {
            const diff = Math.max(0, tot.a - tot.b);
            const base = stakes.gameScore + (bB * stakes.bump);
            let mult = 1;

            if (gA >= 2 && gA <= 4 && tot.b <= 0) mult = 2;
            else if (gA === 9 && tot.b >= 1) mult = 2;
            else if (gA === 9 && tot.b <= 0) mult = 4;
            else if (gA === 15 && tot.b >= 1) mult = 3;
            else if (gA === 15 && tot.b <= 0) mult = 6;

            fA = (base * mult) + (diff * stakes.points);
            fB = -fA;
          } else {
            const diff = Math.max(0, tot.b - tot.a);
            const base = stakes.gameScore + (bA * stakes.bump);
            let mult = 1;

            if (gB >= 2 && gB <= 4 && tot.a <= 0) mult = 2;
            else if (gB === 9 && tot.a >= 1) mult = 2;
            else if (gB === 9 && tot.a <= 0) mult = 4;
            else if (gB === 15 && tot.a >= 1) mult = 3;
            else if (gB === 15 && tot.a <= 0) mult = 6;

            fB = (base * mult) + (diff * stakes.points);
            fA = -fB;
          }

          if (teamA.length === 2 && teamB.length === 3) fA *= 1.5;
          else if (teamB.length === 2 && teamA.length === 3) fB *= 1.5;

          return { scoreA: fA, scoreB: fB, bumpsA: bA, bumpsB: bB, runningA: tot.a, runningB: tot.b };
        };

        const startNewGame = async () => {
          console.log('ðŸŽ® Starting new game...');
          console.log('  - Current table:', currentTable);
          console.log('  - Team A:', teamA);
          console.log('  - Team B:', teamB);
          
          // Clear all game state
          console.log('  - Clearing hands, scores, editing state');
          setHands([]);
          setScoreA('');
          setScoreB('');
          setEditingHandIndex(null);
          
          // Get next game number
          console.log('  - Fetching last game number...');
          const { data: lastGame } = await supabaseClient
            .from('games')
            .select('game_number')
            .eq('table_number', currentTable)
            .order('game_number', { ascending: false })
            .limit(1);

          const num = lastGame && lastGame.length > 0 ? lastGame[0].game_number + 1 : 1;
          console.log('  - Next game number will be:', num);
          
          // Create new game in database
          console.log('  - Creating game in database...');
          const { data: newGame, error } = await supabaseClient
            .from('games')
            .insert({
              game_number: num,
              table_number: currentTable,
              team_a_players: teamA,
              team_b_players: teamB
            })
            .select()
            .single();

          if (error) {
            console.error('  âŒ Error creating game:', error);
            showToast('Error creating game: ' + error.message);
            return;
          }

          if (newGame) {
            setCurrentGameId(newGame.id);
            setGameNumber(newGame.game_number);
            console.log(`âœ… New game created: Game #${newGame.game_number}, ID: ${newGame.id}`);
            console.log('  - Set currentGameId to:', newGame.id);
            console.log('  - Set gameNumber to:', newGame.game_number);
          } else {
            console.error('  âŒ newGame is null/undefined');
          }
        };

        const handleSplitAtGame2 = async (game1, game2) => {
          console.log('ðŸ”€ SPLIT at Game 2: Different winners');
          
          // Save Game 1 as completed set
          await supabaseClient.from('sets').insert({
            team_a_players: teamA,
            team_b_players: teamB,
            team_a_score: game1.scoreA,
            team_b_score: game1.scoreB,
            table_number: currentTable,
            completed_at: new Date().toISOString()
          });

          const completedSet = {
            teamA: [...teamA],
            teamB: [...teamB],
            teamAScore: game1.scoreA,
            teamBScore: game1.scoreB,
            completed_at: new Date().toISOString()
          };
          
          setSetHistory([completedSet, ...setHistory]);
          setAllSets([completedSet, ...allSets]);
          console.log(`âœ… Set saved: Game 1 only (A=${game1.scoreA}, B=${game1.scoreB})`);
          
          // Delete current game from database (will be recreated)
          if (currentGameId) {
            await supabaseClient.from('games').delete().eq('id', currentGameId);
            console.log(`ðŸ—‘ï¸ Deleted old game ID: ${currentGameId}`);
          }
          
          // Create new Game 1 with Game 2's data
          const { data: newGame } = await supabaseClient.from('games').insert({
            game_number: 1,
            team_a_players: teamA,
            team_b_players: teamB,
            winner: game2.winner === 'A' ? 'TeamA' : 'TeamB',
            score_a: game2.scoreA,
            score_b: game2.scoreB,
            running_a: game2.scoreA,
            running_b: game2.scoreB,
            bumps_a: 0,
            bumps_b: 0,
            hands_played: game2.hands?.length || 0,
            table_number: currentTable,
            completed_at: new Date().toISOString()
          }).select().single();
          
          console.log(`âœ… Created new Game 1 from old Game 2, new ID: ${newGame.id}`);
          
          // Save Game 2's hands to new game
          if (game2.hands && game2.hands.length > 0) {
            const handsToInsert = game2.hands.map((hand, idx) => ({
              game_id: newGame.id,
              dealer: hand.dealer,
              score_a: hand.scoreA,
              score_b: hand.scoreB,
              hand_order: idx + 1
            }));
            await supabaseClient.from('hands').insert(handsToInsert);
            console.log(`âœ… Inserted ${handsToInsert.length} hands for new Game 1`);
          }
          
          // Update state - Game 2 is now completed Game 1
          setCurrentGameId(newGame.id);
          setGameNumber(1);
          setCurrentSetGames([{
            gameNumber: 1,
            winner: game2.winner,
            scoreA: game2.scoreA,
            scoreB: game2.scoreB,
            handsPlayed: game2.hands?.length || 0,
            teamA: [...teamA],
            teamB: [...teamB],
            hands: game2.hands || []
          }]);
          
          showToast(`Set complete! Game 1 closed. Starting Game 2...`);
          console.log(`ðŸŽ¯ State updated: Game 1 complete, now starting fresh Game 2`);
          
          // Game 1 is complete, now start fresh Game 2
          await startNewGame();
        };

        const handleSplitAtGame3 = async (game1, game2, game3) => {
          console.log('ðŸ”€ SPLIT at Game 3: Games 1&2 same winner, Game 3 different');
          
          // Calculate total for Games 1&2
          const stA = game1.scoreA + game2.scoreA;
          const stB = game1.scoreB + game2.scoreB;
          
          // Save Games 1&2 as completed set (NO bonus)
          await supabaseClient.from('sets').insert({
            team_a_players: teamA,
            team_b_players: teamB,
            team_a_score: stA,
            team_b_score: stB,
            table_number: currentTable,
            completed_at: new Date().toISOString()
          });

          const completedSet = {
            teamA: [...teamA],
            teamB: [...teamB],
            teamAScore: stA,
            teamBScore: stB,
            completed_at: new Date().toISOString()
          };
          
          setSetHistory([completedSet, ...setHistory]);
          setAllSets([completedSet, ...allSets]);
          console.log(`âœ… Set saved: Games 1-2 (A=${stA}, B=${stB})`);
          
          // Delete current game from database (will be recreated)
          if (currentGameId) {
            await supabaseClient.from('games').delete().eq('id', currentGameId);
            console.log(`ðŸ—‘ï¸ Deleted old game ID: ${currentGameId}`);
          }
          
          // Create new Game 1 with Game 3's data
          const { data: newGame } = await supabaseClient.from('games').insert({
            game_number: 1,
            team_a_players: teamA,
            team_b_players: teamB,
            winner: game3.winner === 'A' ? 'TeamA' : 'TeamB',
            score_a: game3.scoreA,
            score_b: game3.scoreB,
            running_a: game3.scoreA,
            running_b: game3.scoreB,
            bumps_a: 0,
            bumps_b: 0,
            hands_played: game3.hands?.length || 0,
            table_number: currentTable,
            completed_at: new Date().toISOString()
          }).select().single();
          
          console.log(`âœ… Created new Game 1 from old Game 3, new ID: ${newGame.id}`);
          
          // Save Game 3's hands to new game
          if (game3.hands && game3.hands.length > 0) {
            const handsToInsert = game3.hands.map((hand, idx) => ({
              game_id: newGame.id,
              dealer: hand.dealer,
              score_a: hand.scoreA,
              score_b: hand.scoreB,
              hand_order: idx + 1
            }));
            await supabaseClient.from('hands').insert(handsToInsert);
            console.log(`âœ… Inserted ${handsToInsert.length} hands for new Game 1`);
          }
          
          // Update state - Game 3 is now completed Game 1
          setCurrentGameId(newGame.id);
          setGameNumber(1);
          setCurrentSetGames([{
            gameNumber: 1,
            winner: game3.winner,
            scoreA: game3.scoreA,
            scoreB: game3.scoreB,
            handsPlayed: game3.hands?.length || 0,
            teamA: [...teamA],
            teamB: [...teamB],
            hands: game3.hands || []
          }]);
          
          showToast(`Set complete! Games 1-2 closed. Starting Game 2...`);
          console.log(`ðŸŽ¯ State updated: Game 1 complete, now starting fresh Game 2`);
          
          // Game 1 is complete, now start fresh Game 2
          await startNewGame();
        };

        const openEndGameModal = () => {
          if (hands.length === 0) {
            alert('No hands played yet! Add scores first.');
            return;
          }

          setShowEndGameModal(true);
        };

        const endGameWithWinner = async (winner) => {
          const f = calcScore(winner);

          await supabaseClient
            .from('games')
            .update({
              winner: winner === 'A' ? 'TeamA' : 'TeamB',
              score_a: f.scoreA,
              score_b: f.scoreB,
              running_a: f.runningA,
              running_b: f.runningB,
              bumps_a: f.bumpsA,
              bumps_b: f.bumpsB,
              hands_played: hands.length,
              completed_at: new Date().toISOString()
            })
            .eq('id', currentGameId);

          const gr = {
            gameNumber,
            winner,
            scoreA: f.scoreA,
            scoreB: f.scoreB,
            handsPlayed: hands.length,
            teamA: [...teamA],
            teamB: [...teamB],
            hands: [...hands] // Include hands so we can reference them during split
          };

          setCompletedGames([gr, ...completedGames]);
          const newSetGames = [...currentSetGames, gr];
          setCurrentSetGames(newSetGames);
          showToast(`Game ${gameNumber} done! ${winner} wins $${Math.abs(winner === 'A' ? f.scoreA : f.scoreB).toFixed(1)}`);

          // Check for set split after Game 2 (if different winner than Game 1)
          if (newSetGames.length === 2) {
            const game1Winner = newSetGames[0].winner;
            const game2Winner = newSetGames[1].winner;
            
            // If Game 2 winner is DIFFERENT from Game 1 winner, split the set
            if (game1Winner !== game2Winner) {
              // SPLIT: Game 1 becomes complete set, Game 2 becomes new set's Game 1
              const game1 = newSetGames[0];
              const game2 = newSetGames[1]; // Save Game 2 data before clearing
              
              // Save Game 1 as completed set
              await supabaseClient.from('sets').insert({
                team_a_players: teamA,
                team_b_players: teamB,
                team_a_score: game1.scoreA,
                team_b_score: game1.scoreB,
                table_number: currentTable,
                completed_at: new Date().toISOString()
              });

              const completedSet = {
                teamA: [...teamA],
                teamB: [...teamB],
                teamAScore: game1.scoreA,
                teamBScore: game1.scoreB,
                completed_at: new Date().toISOString()
              };
              
              setSetHistory([completedSet, ...setHistory]);
              setAllSets([completedSet, ...allSets]);
              
              // Delete current game from database (will be recreated)
              if (currentGameId) {
                await supabaseClient.from('games').delete().eq('id', currentGameId);
              }
              
              // Create new Game 1 with Game 2's data
              const { data: newGame } = await supabaseClient.from('games').insert({
                game_number: 1, // This is now Game 1 of new set
                team_a_players: teamA,
                team_b_players: teamB,
                winner: game2.winner,
                score_a: game2.scoreA,
                score_b: game2.scoreB,
                running_a: game2.scoreA,
                running_b: game2.scoreB,
                bumps_a: 0,
                bumps_b: 0,
                hands_played: game2.hands?.length || 0,
                table_number: currentTable,
                completed_at: new Date().toISOString()
              }).select().single();
              
              // Save Game 2's hands to new game
              if (game2.hands && game2.hands.length > 0) {
                const handsToInsert = game2.hands.map((hand, idx) => ({
                  game_id: newGame.id,
                  dealer: hand.dealer,
                  score_a: hand.scoreA,
                  score_b: hand.scoreB,
                  hand_order: idx + 1
                }));
                await supabaseClient.from('hands').insert(handsToInsert);
              }
              
              // Update state - Game 2 stays completed, just becomes Game 1
              setCurrentGameId(newGame.id);
              setGameNumber(1);
              setScoreA(game2.scoreA);
              setScoreB(game2.scoreB);
              setHands(game2.hands || []); // Set hands to game2's hands
              setCurrentSetGames([{
                gameNumber: 1,
                winner: game2.winner,
                scoreA: game2.scoreA,
                scoreB: game2.scoreB,
                handsPlayed: game2.hands?.length || 0,
                teamA: [...teamA],
                teamB: [...teamB],
                hands: game2.hands || []
              }]); // Game 2 becomes Game 1 of new set (already completed)
              
              showToast(`Set complete! Game 1 closed. Game 2 becomes new set Game 1.`);
              setShowEndGameModal(false);
              return;
            }
          }

          // Check for set split after Game 3 (if Game 1&2 same winner, Game 3 different)
          if (newSetGames.length === 3) {
            const game1Winner = newSetGames[0].winner;
            const game2Winner = newSetGames[1].winner;
            const game3Winner = newSetGames[2].winner;
            
            // If Games 1&2 won by same team, but Game 3 won by other team, split
            if (game1Winner === game2Winner && game3Winner !== game1Winner) {
              // SPLIT: Games 1&2 become complete set, Game 3 becomes new set's Game 1
              const game3 = newSetGames[2]; // Save Game 3 data before clearing
              
              let stA = 0, stB = 0;
              // Sum first 2 games for the completed set
              newSetGames.slice(0, 2).forEach(game => {
                stA += game.scoreA;
                stB += game.scoreB;
              });

              // NO $25 bonus for 2-0 when split happens
              
              await supabaseClient.from('sets').insert({
                team_a_players: teamA,
                team_b_players: teamB,
                team_a_score: stA,
                team_b_score: stB,
                table_number: currentTable,
                completed_at: new Date().toISOString()
              });

              const completedSet = {
                teamA: [...teamA],
                teamB: [...teamB],
                teamAScore: stA,
                teamBScore: stB,
                completed_at: new Date().toISOString()
              };
              
              setSetHistory([completedSet, ...setHistory]);
              setAllSets([completedSet, ...allSets]);
              
              // Delete current game from database (will be recreated)
              if (currentGameId) {
                await supabaseClient.from('games').delete().eq('id', currentGameId);
              }
              
              // Create new Game 1 with Game 3's data
              const { data: newGame } = await supabaseClient.from('games').insert({
                game_number: 1, // This is now Game 1 of new set
                team_a_players: teamA,
                team_b_players: teamB,
                winner: game3.winner,
                score_a: game3.scoreA,
                score_b: game3.scoreB,
                running_a: game3.scoreA,
                running_b: game3.scoreB,
                bumps_a: 0,
                bumps_b: 0,
                hands_played: game3.hands?.length || 0,
                table_number: currentTable,
                completed_at: new Date().toISOString()
              }).select().single();
              
              // Save Game 3's hands to new game
              if (game3.hands && game3.hands.length > 0) {
                const handsToInsert = game3.hands.map((hand, idx) => ({
                  game_id: newGame.id,
                  dealer: hand.dealer,
                  score_a: hand.scoreA,
                  score_b: hand.scoreB,
                  hand_order: idx + 1
                }));
                await supabaseClient.from('hands').insert(handsToInsert);
              }
              
              // Update state - Game 3 stays completed, just becomes Game 1
              setCurrentGameId(newGame.id);
              setGameNumber(1);
              setScoreA(game3.scoreA);
              setScoreB(game3.scoreB);
              setHands(game3.hands || []); // Set hands to game3's hands
              setCurrentSetGames([{
                gameNumber: 1,
                winner: game3.winner,
                scoreA: game3.scoreA,
                scoreB: game3.scoreB,
                handsPlayed: game3.hands?.length || 0,
                teamA: [...teamA],
                teamB: [...teamB],
                hands: game3.hands || []
              }]); // Game 3 becomes Game 1 of new set (already completed)
              
              showToast(`Set complete! Games 1-2 closed. Game 3 becomes new set Game 1.`);
              setShowEndGameModal(false);
              return;
            }
          }

          // Check for 3-game set completion (no split occurred)
          if (newSetGames.length === 3) {
            let stA = 0, stB = 0;
            newSetGames.forEach(game => {
              stA += game.scoreA;
              stB += game.scoreB;
            });

            const aWins = newSetGames.filter(g => g.winner === 'A').length;
            const bWins = newSetGames.filter(g => g.winner === 'B').length;

            // Add $25 bonus if one team won all 3 games
            if (aWins === 3) {
              stA += stakes.bonus;
              stB -= stakes.bonus;
              showToast(`A wins all 3! +$${stakes.bonus}`);
            } else if (bWins === 3) {
              stB += stakes.bonus;
              stA -= stakes.bonus;
              showToast(`B wins all 3! +$${stakes.bonus}`);
            }

            await supabaseClient.from('sets').insert({
              team_a_players: teamA,
              team_b_players: teamB,
              team_a_score: stA,
              team_b_score: stB,
              table_number: currentTable,
              completed_at: new Date().toISOString()
            });

            const newSet = {
              teamA: [...teamA],
              teamB: [...teamB],
              teamAScore: stA,
              teamBScore: stB,
              completed_at: new Date().toISOString()
            };
            
            setSetHistory([newSet, ...setHistory]);
            setAllSets([newSet, ...allSets]);
            showToast(`Set done! ${stA > stB ? 'A' : 'B'} wins!`);
            setCurrentSetGames([]);
          }

          setHands([]);
          setScoreA(''); // Reset score inputs for next game
          setScoreB(''); // Reset score inputs for next game
          const { data: lastGame } = await supabaseClient
            .from('games')
            .select('game_number')
            .eq('table_number', currentTable)
            .order('game_number', { ascending: false })
            .limit(1);

          const num = lastGame && lastGame.length > 0 ? lastGame[0].game_number + 1 : 1;
          const { data: newGame } = await supabaseClient
            .from('games')
            .insert({
              game_number: num,
              table_number: currentTable,
              team_a_players: teamA,
              team_b_players: teamB
            })
            .select()
            .single();

          if (newGame) {
            setCurrentGameId(newGame.id);
            setGameNumber(newGame.game_number);
          }

          setShowEndGameModal(false);
        };

        const saveStakes = async () => {
          const ns = {
            game_score: stakes.gameScore,
            bump: stakes.bump,
            points: stakes.points,
            bonus: stakes.bonus,
            table_font_size: stakes.tableFontSize
          };

          const { data: existing } = await supabaseClient
            .from('stakes')
            .select('id')
            .limit(1)
            .single();

          if (existing) {
            await supabaseClient.from('stakes').update(ns).eq('id', existing.id);
          } else {
            await supabaseClient.from('stakes').insert(ns);
          }

          showToast('Stakes saved!');
        };

        const endSessionSave = async () => {
          console.log('ðŸ’¾ Ending session - saving sets, resetting view');
          // Keep sets in database, just reset the view
          // Save timestamp to localStorage so it persists across page refreshes
          const now = new Date().toISOString();
          localStorage.setItem(`sessionEnd_table${currentTable}`, now);
          setSessionEndedAt(now);
          
          // Clear all session-related state
          setSetHistory([]);
          setCurrentSetGames([]);
          setCompletedGames([]);
          
          // Start fresh game
          await startNewGame();
          
          setShowEndSessionModal(false);
          showToast('Session ended - view reset. Sets saved in database.');
          console.log('âœ… Session ended, fresh game started');
        };

        const endSessionDiscard = async () => {
          if (!window.confirm('Are you sure? This will permanently delete all sets for this table from the database!')) {
            return;
          }

          console.log('ðŸ—‘ï¸ Discarding session - deleting all sets');
          try {
            // Delete all sets for current table from database
            const { error } = await supabaseClient
              .from('sets')
              .delete()
              .eq('table_number', currentTable);

            if (error) {
              showToast('Error deleting sets: ' + error.message);
              return;
            }

            setSetHistory([]);
            setCurrentSetGames([]);
            setCompletedGames([]);
            
            // Also clear the session end marker since we're deleting everything
            localStorage.removeItem(`sessionEnd_table${currentTable}`);
            setSessionEndedAt(null);
            
            // Start fresh game
            await startNewGame();
            
            setShowEndSessionModal(false);
            showToast('All sets discarded and deleted from database');
            console.log('âœ… Sets deleted, fresh game started');
          } catch (err) {
            showToast('Error: ' + err.message);
          }
        };

        const wipeAllData = async () => {
          if (!window.confirm('âš ï¸ WARNING: This will DELETE ALL DATA from the database (all tables, all games, all hands, all sets). This cannot be undone!\n\nAre you absolutely sure?')) {
            return;
          }
          
          if (!window.confirm('Final confirmation: Delete EVERYTHING from the database?')) {
            return;
          }

          console.log('ðŸ—‘ï¸ðŸ’¥ WIPING ALL DATA FROM DATABASE');
          try {
            // Delete in order: hands â†’ games â†’ sets
            await supabaseClient.from('hands').delete().neq('id', 0); // Delete all
            console.log('âœ… Deleted all hands');
            
            await supabaseClient.from('games').delete().neq('id', 0); // Delete all
            console.log('âœ… Deleted all games');
            
            await supabaseClient.from('sets').delete().neq('id', 0); // Delete all
            console.log('âœ… Deleted all sets');
            
            // Clear all localStorage
            localStorage.clear();
            console.log('âœ… Cleared localStorage');
            
            // Reset all state
            setSetHistory([]);
            setCurrentSetGames([]);
            setCompletedGames([]);
            setSessionEndedAt(null);
            
            // Start completely fresh
            await startNewGame();
            
            showToast('ðŸ—‘ï¸ ALL DATA WIPED - Database is empty, starting fresh');
            console.log('âœ… All data wiped, fresh game started');
          } catch (err) {
            console.error('âŒ Error wiping data:', err);
            showToast('Error wiping data: ' + err.message);
          }
        };

        const endSet = async () => {
          // Can end set with 1, 2, or 3 games
          if (currentSetGames.length === 0) {
            showToast('Cannot end set - no games played');
            setShowEndSetModal(false);
            return;
          }

          // Calculate final scores
          let stA = 0, stB = 0;
          currentSetGames.forEach(game => {
            stA += game.scoreA;
            stB += game.scoreB;
          });

          const aWins = currentSetGames.filter(g => g.winner === 'A').length;
          const bWins = currentSetGames.filter(g => g.winner === 'B').length;

          // Add $25 bonus ONLY if 3 games played and one team won all 3
          if (currentSetGames.length === 3) {
            if (aWins === 3) {
              stA += stakes.bonus;
              stB -= stakes.bonus;
              showToast(`Team A wins all 3! +$${stakes.bonus} bonus`);
            } else if (bWins === 3) {
              stB += stakes.bonus;
              stA -= stakes.bonus;
              showToast(`Team B wins all 3! +$${stakes.bonus} bonus`);
            }
          }

          // Save set to database
          await supabaseClient.from('sets').insert({
            team_a_players: teamA,
            team_b_players: teamB,
            team_a_score: stA,
            team_b_score: stB,
            table_number: currentTable,
            completed_at: new Date().toISOString()
          });

          const newSet = {
            teamA: [...teamA],
            teamB: [...teamB],
            teamAScore: stA,
            teamBScore: stB,
            completed_at: new Date().toISOString()
          };
          
          setSetHistory([newSet, ...setHistory]);
          setAllSets([newSet, ...allSets]);
          
          // Reset for new set
          setCurrentSetGames([]);
          setShowEndSetModal(false);
          showToast(`Set complete with ${currentSetGames.length} game(s)! Starting new set...`);
        };

        // Fetch all sets for date range (for Stats/Leaderboard tabs)
        const fetchAllSetsForDateRange = async (startDate, endDate) => {
          try {
            const start = new Date(startDate + 'T00:00:00').toISOString();
            const end = new Date(endDate + 'T23:59:59').toISOString();
            
            const { data: sets, error } = await supabaseClient
              .from('sets')
              .select('*')
              .gte('completed_at', start)
              .lte('completed_at', end)
              .order('completed_at', { ascending: false });

            if (error) {
              console.error('Error fetching sets:', error);
              return [];
            }

            return sets?.map(s => ({
              teamA: s.team_a_players,
              teamB: s.team_b_players,
              teamAScore: parseFloat(s.team_a_score),
              teamBScore: parseFloat(s.team_b_score),
              completed_at: s.completed_at,
              table_number: s.table_number
            })) || [];
          } catch (err) {
            console.error('Error:', err);
            return [];
          }
        };

        // Calculate totals
        const totA = hands.reduce((sum, h) => sum + h.scoreA, 0);
        const totB = hands.reduce((sum, h) => sum + h.scoreB, 0);
        const currentDealerIdx = dealers.length > 0 ? hands.length % dealers.length : -1;
        const wA = calcScore('A');
        const wB = calcScore('B');

        return (
          <div style={{ fontFamily: "'Manrope', 'Segoe UI', system-ui, sans-serif", background: '#0a0f1e', color: '#e8edf5', minHeight: '100vh' }}>
            {/* Header */}
            <div style={{ background: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)', padding: '1rem 2rem', borderBottom: '3px solid #4f46e5' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', flexWrap: 'wrap' }}>
                <h1 style={{ margin: 0, fontSize: '1.5rem', fontWeight: '800', letterSpacing: '-0.025em' }}>ðŸŽ® Pitch Game Tracker</h1>
                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                  <label style={{ fontWeight: '600', fontSize: '0.875rem' }}>Table:</label>
                  <select
                    value={currentTable}
                    onChange={(e) => setCurrentTable(parseInt(e.target.value))}
                    style={{
                      padding: '0.4rem 0.8rem',
                      borderRadius: '8px',
                      border: '2px solid #4f46e5',
                      background: 'white',
                      color: '#1e293b',
                      fontSize: '0.9rem',
                      fontWeight: '600',
                      cursor: 'pointer'
                    }}
                  >
                    <option value={1}>Table 1</option>
                    <option value={2}>Table 2</option>
                    <option value={3}>Table 3</option>
                    <option value={4}>Table 4</option>
                  </select>
                </div>
              </div>
            </div>

            {/* Tabs */}
            <div style={{ display: 'flex', gap: '0.5rem', padding: '1rem 2rem', borderBottom: '2px solid #1e293b', background: '#0f172a', flexWrap: 'wrap' }}>
              {['game', 'players', 'leaderboard', 'stats', 'settings', 'about'].map(tab => (
                <button
                  key={tab}
                  onClick={() => setActiveTab(tab)}
                  style={{
                    padding: '0.75rem 1.5rem',
                    border: 'none',
                    background: activeTab === tab ? '#6366f1' : 'transparent',
                    color: activeTab === tab ? 'white' : '#94a3b8',
                    borderRadius: '8px',
                    fontWeight: '700',
                    fontSize: '0.95rem',
                    cursor: 'pointer',
                    textTransform: 'capitalize',
                    transition: 'all 0.2s'
                  }}
                >
                  {tab === 'leaderboard' ? 'ðŸ† Leaderboard' : tab === 'stats' ? 'ðŸ“Š Stats' : tab}
                </button>
              ))}
            </div>

            {/* Content */}
            <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '2rem' }}>
              {activeTab === 'game' && (
                <div style={{ background: '#1e293b', borderRadius: '16px', padding: '2rem', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
                  <p style={{ marginBottom: '1rem' }}>
                    <strong>Current Dealer:</strong>{' '}
                    <span style={{ color: '#f59e0b', fontWeight: '600' }}>
                      {dealers.length > 0 && currentDealerIdx >= 0 ? dealers[currentDealerIdx] : 'Not selected'}
                    </span>
                  </p>

                  {dealers.length > 0 && (
                    <div style={{ margin: '1rem 0', padding: '1rem', background: '#0f172a', borderRadius: '12px', border: '2px solid #334155' }}>
                      <strong>Dealer Rotation:</strong>
                      <div style={{ marginTop: '0.75rem', display: 'flex', gap: '0.75rem', flexWrap: 'wrap' }}>
                        {dealers.map((d, i) => (
                          <div
                            key={i}
                            style={{
                              padding: '0.5rem 1rem',
                              background: i === currentDealerIdx ? '#6366f1' : '#334155',
                              color: 'white',
                              borderRadius: '8px',
                              fontWeight: i === currentDealerIdx ? '700' : '400',
                              fontSize: '0.9rem'
                            }}
                          >
                            {i === currentDealerIdx ? 'â˜… ' : ''}{d}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1.5rem' }}>
                    <button onClick={openScoreModal} style={buttonStyle('#6366f1')}>Add Score</button>
                    <button onClick={openDealerModal} style={buttonStyle('#10b981')}>Select Dealers</button>
                    <button onClick={openEndGameModal} style={buttonStyle('#ef4444')}>End Game</button>
                    <button 
                      onClick={() => setShowEndSetModal(true)} 
                      style={{
                        ...buttonStyle('#f59e0b'),
                        opacity: currentSetGames.length > 0 ? 1 : 0.5,
                        cursor: currentSetGames.length > 0 ? 'pointer' : 'not-allowed'
                      }}
                      disabled={currentSetGames.length === 0}
                    >
                      End Set {currentSetGames.length > 0 ? `(${currentSetGames.length})` : '(0/3)'}
                    </button>
                    <button onClick={() => setShowEndSessionModal(true)} style={buttonStyle('#8b5cf6')}>End Session</button>
                    <button onClick={wipeAllData} style={{ ...buttonStyle('#dc2626'), fontSize: '0.875rem' }}>âš ï¸ Wipe All Data</button>
                  </div>

                  <h3 style={{ marginTop: '2rem', marginBottom: '1rem', fontSize: '1.25rem', fontWeight: '700' }}>Scores</h3>
                  <div style={{ display: 'grid', gridTemplateColumns: window.innerWidth < 768 ? '1fr' : '1fr 1fr', gap: '1rem' }}>
                    <div style={{ background: '#0f172a', padding: '1.5rem', borderRadius: '12px', border: '3px solid #10b981' }}>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', marginBottom: '0.5rem' }}>
                        <h4 style={{ margin: 0, color: '#10b981', fontSize: '1rem' }}>Team A</h4>
                        <span style={{ color: '#94a3b8', fontSize: '0.875rem' }}>({teamA.join(', ') || 'No players'})</span>
                      </div>
                      <div style={{ fontSize: '3rem', fontWeight: '800', color: '#10b981' }}>{totA.toFixed(0)}</div>
                    </div>
                    <div style={{ background: '#0f172a', padding: '1.5rem', borderRadius: '12px', border: '3px solid #f59e0b' }}>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', marginBottom: '0.5rem' }}>
                        <h4 style={{ margin: 0, color: '#f59e0b', fontSize: '1rem' }}>Team B</h4>
                        <span style={{ color: '#94a3b8', fontSize: '0.875rem' }}>({teamB.join(', ') || 'No players'})</span>
                      </div>
                      <div style={{ fontSize: '3rem', fontWeight: '800', color: '#f59e0b' }}>{totB.toFixed(0)}</div>
                    </div>
                  </div>

                  <div style={{ display: 'grid', gridTemplateColumns: window.innerWidth < 1024 ? '1fr' : '1fr 2fr', gap: '2rem', marginTop: '2rem' }}>
                    <div>
                      <h3 style={{ marginBottom: '1rem', fontSize: '1.25rem', fontWeight: '700' }}>Hands</h3>
                      <div style={{ overflowX: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse', background: '#0f172a', borderRadius: '8px', overflow: 'hidden' }}>
                          <thead>
                            <tr style={{ background: '#334155' }}>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Dealer</th>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>A</th>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>B</th>
                            </tr>
                          </thead>
                          <tbody>
                            {hands.length === 0 ? (
                              <tr>
                                <td colSpan={3} style={{ padding: '1rem', textAlign: 'center', color: '#64748b' }}>No hands yet</td>
                              </tr>
                            ) : (
                              hands.map((h, idx) => {
                                let rA = 0, rB = 0;
                                for (let i = 0; i <= idx; i++) {
                                  rA += hands[i].scoreA;
                                  rB += hands[i].scoreB;
                                }
                                return (
                                  <tr
                                    key={idx}
                                    onClick={() => editHand(idx)}
                                    style={{
                                      cursor: 'pointer',
                                      background: idx % 2 === 0 ? '#1e293b' : '#0f172a'
                                    }}
                                  >
                                    <td style={{ padding: '0.5rem', fontSize: `${stakes.tableFontSize}rem` }}>{h.dealer}</td>
                                    <td style={{ padding: '0.5rem', fontSize: `${stakes.tableFontSize}rem`, color: '#10b981', fontWeight: '600' }}>{rA.toFixed(0)}</td>
                                    <td style={{ padding: '0.5rem', fontSize: `${stakes.tableFontSize}rem`, color: '#f59e0b', fontWeight: '600' }}>{rB.toFixed(0)}</td>
                                  </tr>
                                );
                              })
                            )}
                          </tbody>
                        </table>
                      </div>
                    </div>

                    <div>
                      <div style={{ marginBottom: '2rem' }}>
                        <h3 style={{ marginBottom: '1rem', fontSize: '1.25rem', fontWeight: '700' }}>Total Summary</h3>
                        <table style={{ width: '100%', borderCollapse: 'collapse', background: '#0f172a', borderRadius: '8px', overflow: 'hidden' }}>
                          <thead>
                            <tr style={{ background: '#334155' }}>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Team</th>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Players</th>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Game 1</th>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Game 2</th>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Game 3</th>
                              <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Total</th>
                            </tr>
                          </thead>
                          <tbody>
                            <tr style={{ background: '#1e293b' }}>
                              <td style={{ padding: '0.75rem', fontWeight: '600', fontSize: `${stakes.tableFontSize}rem` }}>A</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{teamA.join(', ') || '-'}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{currentSetGames[0]?.scoreA.toFixed(0) || '-'}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{currentSetGames[1]?.scoreA.toFixed(0) || '-'}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{currentSetGames[2]?.scoreA.toFixed(0) || '-'}</td>
                              <td style={{ padding: '0.75rem', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>
                                {currentSetGames.length > 0 ? currentSetGames.reduce((sum, g) => sum + g.scoreA, 0).toFixed(1) : '-'}
                              </td>
                            </tr>
                            <tr style={{ background: '#0f172a' }}>
                              <td style={{ padding: '0.75rem', fontWeight: '600', fontSize: `${stakes.tableFontSize}rem` }}>B</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{teamB.join(', ') || '-'}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{currentSetGames[0]?.scoreB.toFixed(0) || '-'}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{currentSetGames[1]?.scoreB.toFixed(0) || '-'}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{currentSetGames[2]?.scoreB.toFixed(0) || '-'}</td>
                              <td style={{ padding: '0.75rem', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>
                                {currentSetGames.length > 0 ? currentSetGames.reduce((sum, g) => sum + g.scoreB, 0).toFixed(1) : '-'}
                              </td>
                            </tr>
                          </tbody>
                        </table>
                      </div>

                      <div>
                        <h3 style={{ marginBottom: '1rem', fontSize: '1.25rem', fontWeight: '700' }}>Sets</h3>
                      <div style={{ border: '2px solid #334155', borderRadius: '8px', overflow: 'hidden' }}>
                        <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
                          <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead style={{ position: 'sticky', top: 0, zIndex: 10 }}>
                              <tr style={{ background: '#334155' }}>
                                <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem`, width: '80px' }}>Set #</th>
                                {(() => {
                                  // Collect unique players from set history
                                  const allPlayers = [];
                                  setHistory.forEach(set => {
                                    set.teamA.forEach(p => {
                                      if (!allPlayers.includes(p)) allPlayers.push(p);
                                    });
                                    set.teamB.forEach(p => {
                                      if (!allPlayers.includes(p)) allPlayers.push(p);
                                    });
                                  });
                                  return allPlayers.map(p => (
                                    <th key={p} style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem`, minWidth: '120px' }}>{p}</th>
                                  ));
                                })()}
                              </tr>
                              <tr style={{ background: '#334155', fontWeight: '700', position: 'sticky', top: '49px', zIndex: 9 }}>
                                <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem` }}>Total</th>
                                {(() => {
                                  // Calculate totals for each player
                                  const allPlayers = [];
                                  const playerTotals = {};
                                  
                                  setHistory.forEach(set => {
                                    set.teamA.forEach(p => {
                                      if (!allPlayers.includes(p)) {
                                        allPlayers.push(p);
                                        playerTotals[p] = 0;
                                      }
                                    });
                                    set.teamB.forEach(p => {
                                      if (!allPlayers.includes(p)) {
                                        allPlayers.push(p);
                                        playerTotals[p] = 0;
                                      }
                                    });
                                  });

                                  setHistory.forEach(set => {
                                    const aMult = set.teamA.length < set.teamB.length ? 1.5 : 1;
                                    const bMult = set.teamB.length < set.teamA.length ? 1.5 : 1;
                                    
                                    allPlayers.forEach(p => {
                                      if (set.teamA.includes(p)) {
                                        playerTotals[p] += set.teamAScore * aMult;
                                      }
                                      if (set.teamB.includes(p)) {
                                        playerTotals[p] += set.teamBScore * bMult;
                                      }
                                    });
                                  });

                                  return allPlayers.map(p => {
                                    const total = playerTotals[p];
                                    const color = total >= 0 ? '#10b981' : '#ef4444';
                                    return (
                                      <th key={p} style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, color }}>${total.toFixed(1)}</th>
                                    );
                                  });
                                })()}
                              </tr>
                            </thead>
                            <tbody>
                              {setHistory.length === 0 ? (
                                <tr>
                                  <td colSpan={10} style={{ padding: '1rem', textAlign: 'center', color: '#64748b', background: '#0f172a' }}>No sets yet</td>
                                </tr>
                              ) : (
                                setHistory.map((set, idx) => {
                                  // Collect unique players
                                  const allPlayers = [];
                                  setHistory.forEach(s => {
                                    s.teamA.forEach(p => {
                                      if (!allPlayers.includes(p)) allPlayers.push(p);
                                    });
                                    s.teamB.forEach(p => {
                                      if (!allPlayers.includes(p)) allPlayers.push(p);
                                    });
                                  });

                                  const aMult = set.teamA.length < set.teamB.length ? 1.5 : 1;
                                  const bMult = set.teamB.length < set.teamA.length ? 1.5 : 1;

                                  return (
                                    <tr key={idx} style={{ background: idx % 2 === 0 ? '#1e293b' : '#0f172a' }}>
                                      <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{setHistory.length - idx}</td>
                                      {allPlayers.map(p => {
                                        let val = 0;
                                        if (set.teamA.includes(p)) val = set.teamAScore * aMult;
                                        if (set.teamB.includes(p)) val = set.teamBScore * bMult;
                                        
                                        return (
                                          <td key={p} style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, color: val !== 0 ? '#6366f1' : '#64748b', fontWeight: val !== 0 ? '600' : '400' }}>
                                            {val !== 0 ? `$${val.toFixed(1)}` : '-'}
                                          </td>
                                        );
                                      })}
                                    </tr>
                                  );
                                })
                              )}
                            </tbody>
                          </table>
                        </div>
                      </div>
                    </div>
                  </div>
                  </div>
                </div>
              )}

              {activeTab === 'players' && (
                <div style={{ background: '#1e293b', borderRadius: '16px', padding: '2rem', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
                  <h2 style={{ margin: '0 0 1.5rem 0', fontSize: '1.5rem', fontWeight: '700' }}>Manage Players</h2>
                  <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '2rem', flexWrap: 'wrap' }}>
                    <input
                      type="text"
                      value={newPlayerName}
                      onChange={(e) => setNewPlayerName(e.target.value)}
                      placeholder="Player name"
                      maxLength={8}
                      style={{
                        flex: 1,
                        minWidth: '200px',
                        padding: '0.75rem',
                        border: '2px solid #334155',
                        borderRadius: '8px',
                        background: '#0f172a',
                        color: '#e8edf5',
                        fontSize: '1rem'
                      }}
                      onKeyPress={(e) => e.key === 'Enter' && addPlayer()}
                    />
                    <button onClick={addPlayer} style={buttonStyle('#6366f1')}>Add Player</button>
                  </div>

                  <h3 style={{ marginBottom: '1rem', fontSize: '1.25rem', fontWeight: '700' }}>Players</h3>
                  {players.length === 0 ? (
                    <p style={{ color: '#64748b' }}>No players yet. Add one above!</p>
                  ) : (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                      {players.map(p => {
                        const inA = teamA.includes(p);
                        const inB = teamB.includes(p);
                        return (
                          <div
                            key={p}
                            onClick={() => toggleTeam(p)}
                            style={{
                              display: 'flex',
                              justifyContent: 'space-between',
                              padding: '1rem',
                              background: '#0f172a',
                              borderRadius: '8px',
                              cursor: 'pointer',
                              border: '2px solid #334155',
                              transition: 'all 0.2s'
                            }}
                          >
                            <span style={{ fontWeight: '600' }}>{p}</span>
                            {inA && <span style={{ padding: '0.25rem 0.75rem', borderRadius: '12px', background: '#10b981', color: 'white', fontSize: '0.75rem', fontWeight: '700' }}>Team A</span>}
                            {inB && <span style={{ padding: '0.25rem 0.75rem', borderRadius: '12px', background: '#f59e0b', color: 'white', fontSize: '0.75rem', fontWeight: '700' }}>Team B</span>}
                          </div>
                        );
                      })}
                    </div>
                  )}
                  <p style={{ marginTop: '1rem', color: '#64748b', fontSize: '0.875rem' }}>
                    Click: None â†’ Team A â†’ Team B â†’ None
                  </p>
                </div>
              )}

              {activeTab === 'leaderboard' && (
                <div style={{ background: '#1e293b', borderRadius: '16px', padding: '2rem', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
                  <h2 style={{ margin: '0 0 1.5rem 0', fontSize: '1.5rem', fontWeight: '700' }}>ðŸ† Player Leaderboard</h2>
                  
                  {/* Date Filters */}
                  <div style={{ background: '#0f172a', padding: '1.5rem', borderRadius: '12px', marginBottom: '1.5rem' }}>
                    <h3 style={{ margin: '0 0 1rem 0', fontSize: '1rem', fontWeight: '700' }}>Date Range</h3>
                    <div style={{ display: 'grid', gridTemplateColumns: window.innerWidth < 768 ? '1fr' : '1fr 1fr', gap: '1rem' }}>
                      <div>
                        <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.875rem', color: '#94a3b8', fontWeight: '600' }}>Start Date:</label>
                        <input 
                          type="date" 
                          value={leaderboardStartDate}
                          onChange={(e) => setLeaderboardStartDate(e.target.value)}
                          style={inputStyle}
                        />
                      </div>
                      <div>
                        <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.875rem', color: '#94a3b8', fontWeight: '600' }}>End Date:</label>
                        <input 
                          type="date" 
                          value={leaderboardEndDate}
                          onChange={(e) => setLeaderboardEndDate(e.target.value)}
                          style={inputStyle}
                        />
                      </div>
                    </div>
                  </div>
                  
                  {(() => {
                    // Filter sets by date range (use allSets to show all historical data)
                    // Use pre-fetched leaderboard sets (already filtered by date in database query)
                    const filteredSets = leaderboardSets;
                    console.log('Leaderboard rendering with', filteredSets.length, 'sets');
                    console.log('Sample set:', filteredSets[0]);

                    if (filteredSets.length === 0) {
                      return (
                        <div style={{ padding: '3rem', textAlign: 'center', color: '#64748b', background: '#0f172a', borderRadius: '12px' }}>
                          <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>ðŸ†</div>
                          <p style={{ fontSize: '1.1rem' }}>No sets found in this date range</p>
                          <p style={{ marginTop: '0.5rem', fontSize: '0.9rem' }}>Try adjusting your date filters</p>
                        </div>
                      );
                    }

                    const playerStats = {};

                    filteredSets.forEach(set => {
                      console.log('Processing set:', set);
                      const aMult = set.teamA.length < set.teamB.length ? 1.5 : 1;
                      const bMult = set.teamB.length < set.teamA.length ? 1.5 : 1;

                      set.teamA.forEach(p => {
                        if (!playerStats[p]) {
                          playerStats[p] = { sets: 0, wins: 0, losses: 0, totalEarnings: 0 };
                        }
                        playerStats[p].sets++;
                        const earnings = set.teamAScore * aMult;
                        playerStats[p].totalEarnings += earnings;
                        if (set.teamAScore > set.teamBScore) playerStats[p].wins++;
                        else playerStats[p].losses++;
                      });

                      set.teamB.forEach(p => {
                        if (!playerStats[p]) {
                          playerStats[p] = { sets: 0, wins: 0, losses: 0, totalEarnings: 0 };
                        }
                        playerStats[p].sets++;
                        const earnings = set.teamBScore * bMult;
                        playerStats[p].totalEarnings += earnings;
                        if (set.teamBScore > set.teamAScore) playerStats[p].wins++;
                        else playerStats[p].losses++;
                      });
                    });

                    console.log('Player stats:', playerStats);

                    const sortedPlayers = Object.keys(playerStats).sort((a, b) => 
                      playerStats[b].totalEarnings - playerStats[a].totalEarnings
                    );

                    console.log('Sorted players:', sortedPlayers);

                    return (
                      <div>
                        {/* Leaderboard Table */}
                        <div style={{ background: '#0f172a', borderRadius: '12px', overflow: 'hidden', marginBottom: '2rem' }}>
                          <div style={{ overflowX: 'auto' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                              <thead>
                                <tr style={{ background: '#334155' }}>
                                  <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>Rank</th>
                                  <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>Player</th>
                                  <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>Sets</th>
                                  <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>Wins</th>
                                  <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>Losses</th>
                                  <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>Win %</th>
                                  <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>Total Earnings</th>
                                  <th style={{ padding: '0.75rem', textAlign: 'left', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>Avg/Set</th>
                                </tr>
                              </thead>
                              <tbody>
                                {sortedPlayers.map((p, index) => {
                                  const stats = playerStats[p];
                                  const winPct = ((stats.wins / stats.sets) * 100).toFixed(1);
                                  const avgPerSet = (stats.totalEarnings / stats.sets).toFixed(1);
                                  const earningsColor = stats.totalEarnings >= 0 ? '#10b981' : '#ef4444';
                                  
                                  let rankDisplay = index + 1;
                                  if (index === 0) rankDisplay = 'ðŸ¥‡';
                                  else if (index === 1) rankDisplay = 'ðŸ¥ˆ';
                                  else if (index === 2) rankDisplay = 'ðŸ¥‰';

                                  return (
                                    <tr key={p} style={{ background: index % 2 === 0 ? '#1e293b' : '#0f172a', borderBottom: '1px solid #334155' }}>
                                      <td style={{ padding: '0.75rem', fontSize: '1.2rem' }}>{rankDisplay}</td>
                                      <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700', color: '#e2e8f0' }}>{p}</td>
                                      <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, color: '#94a3b8' }}>{stats.sets}</td>
                                      <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, color: '#10b981', fontWeight: '600' }}>{stats.wins}</td>
                                      <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, color: '#ef4444', fontWeight: '600' }}>{stats.losses}</td>
                                      <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, color: '#94a3b8' }}>{winPct}%</td>
                                      <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700', color: earningsColor }}>${stats.totalEarnings.toFixed(1)}</td>
                                      <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, color: '#94a3b8' }}>${avgPerSet}</td>
                                    </tr>
                                  );
                                })}
                              </tbody>
                            </table>
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                </div>
              )}

              {activeTab === 'stats' && (
                <div style={{ background: '#1e293b', borderRadius: '16px', padding: '2rem', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
                  {/* Date Filters */}
                  <div style={{ background: '#0f172a', padding: '1.5rem', borderRadius: '12px', marginBottom: '1.5rem' }}>
                    <h3 style={{ margin: '0 0 1rem 0', fontSize: '1rem', fontWeight: '700' }}>Date Range</h3>
                    <div style={{ display: 'grid', gridTemplateColumns: window.innerWidth < 768 ? '1fr' : '1fr 1fr', gap: '1rem' }}>
                      <div>
                        <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.875rem', color: '#94a3b8', fontWeight: '600' }}>Start Date:</label>
                        <input 
                          type="date" 
                          value={statsStartDate}
                          onChange={(e) => setStatsStartDate(e.target.value)}
                          style={inputStyle}
                        />
                      </div>
                      <div>
                        <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.875rem', color: '#94a3b8', fontWeight: '600' }}>End Date:</label>
                        <input 
                          type="date" 
                          value={statsEndDate}
                          onChange={(e) => setStatsEndDate(e.target.value)}
                          style={inputStyle}
                        />
                      </div>
                    </div>
                  </div>

                  {/* Set History Table */}
                  <h3 style={{ marginBottom: '1rem', fontSize: '1.25rem', fontWeight: '700' }}>Set History</h3>
                  <div style={{ overflowX: 'auto' }}>
                    <table style={{ width: '100%', borderCollapse: 'collapse', background: '#0f172a', borderRadius: '8px', overflow: 'hidden' }}>
                      <thead>
                        <tr style={{ background: '#334155' }}>
                          <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Set</th>
                          <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Team A</th>
                          <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Team B</th>
                          <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>A Score</th>
                          <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>B Score</th>
                          <th style={{ padding: '0.75rem', textAlign: 'left', fontWeight: '700', fontSize: `${stakes.tableFontSize}rem` }}>Winner</th>
                        </tr>
                      </thead>
                      <tbody>
                        {(() => {
                          // Filter sets by date range
                          // Use pre-fetched stats sets (already filtered by date in database query)
                          const filteredSets = statsSets;

                          if (filteredSets.length === 0) {
                            return (
                              <tr>
                                <td colSpan={6} style={{ padding: '1rem', textAlign: 'center', color: '#64748b' }}>No sets in this date range</td>
                              </tr>
                            );
                          }

                          return filteredSets.map((s, i) => (
                            <tr key={i} style={{ background: i % 2 === 0 ? '#1e293b' : '#0f172a' }}>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{filteredSets.length - i}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{s.teamA.join(', ')}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem` }}>{s.teamB.join(', ')}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, color: '#10b981', fontWeight: '600' }}>{s.teamAScore.toFixed(1)}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, color: '#f59e0b', fontWeight: '600' }}>{s.teamBScore.toFixed(1)}</td>
                              <td style={{ padding: '0.75rem', fontSize: `${stakes.tableFontSize}rem`, fontWeight: '700' }}>{s.teamAScore > s.teamBScore ? 'Team A' : 'Team B'}</td>
                            </tr>
                          ));
                        })()}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {activeTab === 'settings' && (
                <div style={{ background: '#1e293b', borderRadius: '16px', padding: '2rem', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
                  <h2 style={{ margin: '0 0 1.5rem 0', fontSize: '1.5rem', fontWeight: '700' }}>Settings - Stakes</h2>
                  <div style={{ display: 'grid', gap: '1rem', maxWidth: '400px' }}>
                    <div>
                      <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600' }}>Game:</label>
                      <input
                        type="number"
                        value={stakes.gameScore}
                        onChange={(e) => setStakes({ ...stakes, gameScore: parseFloat(e.target.value) })}
                        min="0"
                        step="1"
                        style={inputStyle}
                      />
                    </div>
                    <div>
                      <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600' }}>Bump:</label>
                      <input
                        type="number"
                        value={stakes.bump}
                        onChange={(e) => setStakes({ ...stakes, bump: parseFloat(e.target.value) })}
                        min="0"
                        step="1"
                        style={inputStyle}
                      />
                    </div>
                    <div>
                      <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600' }}>Points:</label>
                      <input
                        type="number"
                        value={stakes.points}
                        onChange={(e) => setStakes({ ...stakes, points: parseFloat(e.target.value) })}
                        min="0"
                        step="0.5"
                        style={inputStyle}
                      />
                    </div>
                    <div>
                      <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600' }}>Bonus:</label>
                      <input
                        type="number"
                        value={stakes.bonus}
                        onChange={(e) => setStakes({ ...stakes, bonus: parseFloat(e.target.value) })}
                        min="0"
                        step="1"
                        style={inputStyle}
                      />
                    </div>
                    <div>
                      <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600' }}>Table Font Size (rem):</label>
                      <input
                        type="number"
                        value={stakes.tableFontSize}
                        onChange={(e) => setStakes({ ...stakes, tableFontSize: parseFloat(e.target.value) })}
                        min="0.5"
                        max="2"
                        step="0.1"
                        style={inputStyle}
                      />
                      <p style={{ fontSize: '0.75rem', color: '#94a3b8', marginTop: '0.25rem' }}>Default: 0.9 | Range: 0.5-2.0</p>
                    </div>
                    <button onClick={saveStakes} style={buttonStyle('#6366f1')}>Save Settings</button>
                  </div>
                </div>
              )}

              {activeTab === 'about' && (
                <div style={{ background: '#1e293b', borderRadius: '16px', padding: '2rem', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
                  <h2 style={{ margin: '0 0 1.5rem 0', fontSize: '1.5rem', fontWeight: '700' }}>About Pitch Game Tracker</h2>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', padding: '1rem 0', borderBottom: '1px solid #334155' }}>
                      <span style={{ fontWeight: '600', color: '#94a3b8' }}>Games Played</span>
                      <span style={{ color: '#6366f1', fontWeight: '700', fontSize: '1.1rem' }}>#{gameNumber}</span>
                    </div>
                    <div style={{ display: 'flex', justifyContent: 'space-between', padding: '1rem 0', borderBottom: '1px solid #334155' }}>
                      <span style={{ fontWeight: '600', color: '#94a3b8' }}>Version</span>
                      <span>2.2.0 (React)</span>
                    </div>
                    <div style={{ display: 'flex', justifyContent: 'space-between', padding: '1rem 0', borderBottom: '1px solid #334155' }}>
                      <span style={{ fontWeight: '600', color: '#94a3b8' }}>Last Updated</span>
                      <span>Feb 8, 2026</span>
                    </div>
                    <div style={{ display: 'flex', justifyContent: 'space-between', padding: '1rem 0' }}>
                      <span style={{ fontWeight: '600', color: '#94a3b8' }}>Description</span>
                      <span>Multi-table pitch game scoring system</span>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Score Modal */}
            <Modal show={showScoreModal} onClose={() => setShowScoreModal(false)}>
              <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.5rem', fontWeight: '700', color: '#1e293b' }}>
                {editingHandIndex !== null ? 'Edit Hand' : 'Add Score'}
              </h2>
              <p style={{ color: '#64748b', marginBottom: '1rem' }}>Enter scores for this hand</p>
              <div style={{ marginBottom: '1rem' }}>
                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600', color: '#1e293b' }}>Team A Score:</label>
                <input
                  type="number"
                  value={scoreA}
                  onChange={(e) => setScoreA(e.target.value)}
                  step="0.5"
                  style={{ width: '100%', padding: '0.75rem', border: '2px solid #e2e8f0', borderRadius: '8px', background: 'white', color: '#1e293b', fontSize: '1rem' }}
                  autoFocus
                />
              </div>
              <div style={{ marginBottom: '1.5rem' }}>
                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600', color: '#1e293b' }}>Team B Score:</label>
                <input
                  type="number"
                  value={scoreB}
                  onChange={(e) => setScoreB(e.target.value)}
                  step="0.5"
                  style={{ width: '100%', padding: '0.75rem', border: '2px solid #e2e8f0', borderRadius: '8px', background: 'white', color: '#1e293b', fontSize: '1rem' }}
                />
              </div>
              <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                <button onClick={confirmScore} style={buttonStyle('#6366f1')}>
                  {editingHandIndex !== null ? 'Update' : 'Add Score'}
                </button>
                <button onClick={() => setShowScoreModal(false)} style={buttonStyle('#64748b')}>Cancel</button>
              </div>
            </Modal>

            {/* Dealer Modal */}
            <Modal show={showDealerModal} onClose={() => setShowDealerModal(false)}>
              <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.5rem', fontWeight: '700', color: '#1e293b' }}>Select Dealer Order</h2>
              <p style={{ color: '#64748b', marginBottom: '1rem' }}>Click players in order (4 dealers needed)</p>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem', marginBottom: '1.5rem' }}>
                {[...teamA, ...teamB].map(p => {
                  const isSelected = tempDealers.includes(p);
                  const index = tempDealers.indexOf(p);
                  return (
                    <div
                      key={p}
                      onClick={() => toggleDealer(p)}
                      style={{
                        padding: '1rem',
                        background: isSelected ? '#6366f1' : '#f1f5f9',
                        color: isSelected ? 'white' : '#1e293b',
                        borderRadius: '8px',
                        cursor: 'pointer',
                        fontWeight: isSelected ? '700' : '400',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center'
                      }}
                    >
                      <span>{p}</span>
                      {isSelected && (
                        <span style={{
                          background: 'white',
                          color: '#6366f1',
                          padding: '0.25rem 0.75rem',
                          borderRadius: '12px',
                          fontWeight: '700',
                          fontSize: '0.875rem'
                        }}>
                          {index + 1}
                        </span>
                      )}
                    </div>
                  );
                })}
              </div>
              <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                <button onClick={confirmDealers} style={buttonStyle('#6366f1')}>Confirm</button>
                <button onClick={() => setShowDealerModal(false)} style={buttonStyle('#64748b')}>Cancel</button>
              </div>
            </Modal>

            {/* End Game Modal */}
            <Modal show={showEndGameModal} onClose={() => setShowEndGameModal(false)}>
              <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.5rem', fontWeight: '700', color: '#1e293b' }}>End Game</h2>
              <div style={{ margin: '1.5rem 0', padding: '1rem', background: '#f8fafc', borderRadius: '8px' }}>
                <div style={{ display: 'grid', gridTemplateColumns: window.innerWidth < 768 ? '1fr' : '1fr 1fr', gap: '1rem' }}>
                  <div style={{ padding: '1rem', background: '#dcfce7', borderRadius: '8px' }}>
                    <h3 style={{ color: '#166534', marginBottom: '0.5rem', fontSize: '1.1rem', fontWeight: '700' }}>Team A</h3>
                    <p style={{ color: '#1e293b', marginBottom: '0.25rem' }}><strong>Running:</strong> {wA.runningA.toFixed(1)}</p>
                    <p style={{ color: '#1e293b', marginBottom: '0.25rem' }}><strong>Final:</strong> {wA.scoreA.toFixed(1)}</p>
                    <p style={{ color: '#1e293b' }}><strong>Opp. Bumps:</strong> {wA.bumpsB}</p>
                  </div>
                  <div style={{ padding: '1rem', background: '#fed7aa', borderRadius: '8px' }}>
                    <h3 style={{ color: '#92400e', marginBottom: '0.5rem', fontSize: '1.1rem', fontWeight: '700' }}>Team B</h3>
                    <p style={{ color: '#1e293b', marginBottom: '0.25rem' }}><strong>Running:</strong> {wB.runningB.toFixed(1)}</p>
                    <p style={{ color: '#1e293b', marginBottom: '0.25rem' }}><strong>Final:</strong> {wB.scoreB.toFixed(1)}</p>
                    <p style={{ color: '#1e293b' }}><strong>Opp. Bumps:</strong> {wB.bumpsA}</p>
                  </div>
                </div>
              </div>
              <p style={{ color: '#64748b', marginBottom: '1rem', fontWeight: '600' }}>Select the winning team:</p>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                <button 
                  onClick={() => endGameWithWinner('A')} 
                  disabled={wA.runningA < 9}
                  style={{ 
                    ...buttonStyle('#10b981'), 
                    padding: '1rem',
                    opacity: wA.runningA < 9 ? 0.5 : 1,
                    cursor: wA.runningA < 9 ? 'not-allowed' : 'pointer'
                  }}
                >
                  Team A Wins {wA.runningA < 9 ? '(Need 9+)' : ''}
                </button>
                <button 
                  onClick={() => endGameWithWinner('B')} 
                  disabled={wB.runningB < 9}
                  style={{ 
                    ...buttonStyle('#f59e0b'), 
                    padding: '1rem',
                    opacity: wB.runningB < 9 ? 0.5 : 1,
                    cursor: wB.runningB < 9 ? 'not-allowed' : 'pointer'
                  }}
                >
                  Team B Wins {wB.runningB < 9 ? '(Need 9+)' : ''}
                </button>
                <button onClick={() => setShowEndGameModal(false)} style={{ ...buttonStyle('#64748b'), padding: '1rem' }}>Cancel</button>
              </div>
            </Modal>

            {/* End Set Modal */}
            <Modal show={showEndSetModal} onClose={() => setShowEndSetModal(false)}>
              <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.5rem', fontWeight: '700', color: '#1e293b' }}>End Set</h2>
              <p style={{ color: '#64748b', marginBottom: '1rem' }}>
                Complete this set and start a new one?
              </p>
              <div style={{ background: '#f8fafc', padding: '1rem', borderRadius: '8px', marginBottom: '1.5rem' }}>
                <p style={{ color: '#1e293b', marginBottom: '0.5rem' }}><strong>Current Set:</strong></p>
                <p style={{ color: '#64748b', fontSize: '0.875rem' }}>Games completed: <strong>{currentSetGames.length}</strong></p>
                {currentSetGames.length > 0 && (() => {
                  const aWins = currentSetGames.filter(g => g.winner === 'A').length;
                  const bWins = currentSetGames.filter(g => g.winner === 'B').length;
                  let stA = 0, stB = 0;
                  currentSetGames.forEach(game => {
                    stA += game.scoreA;
                    stB += game.scoreB;
                  });
                  const willGetBonus = currentSetGames.length === 3 && (aWins === 3 || bWins === 3);
                  return (
                    <>
                      <p style={{ color: '#64748b', fontSize: '0.875rem' }}>Team A wins: <strong>{aWins}</strong> | Team B wins: <strong>{bWins}</strong></p>
                      <p style={{ color: '#64748b', fontSize: '0.875rem' }}>Current total: Team A <strong>${stA.toFixed(1)}</strong> | Team B <strong>${stB.toFixed(1)}</strong></p>
                      {willGetBonus && (
                        <p style={{ color: '#10b981', fontSize: '0.875rem', marginTop: '0.5rem' }}>
                          â­ <strong>{aWins === 3 ? 'Team A' : 'Team B'} wins all 3 games! +${stakes.bonus} bonus</strong>
                        </p>
                      )}
                    </>
                  );
                })()}
              </div>
              <div style={{ display: 'flex', gap: '0.5rem' }}>
                <button 
                  onClick={endSet}
                  style={{ ...buttonStyle('#f59e0b'), padding: '1rem', flex: 1 }}
                >
                  ðŸ End Set & Start New
                </button>
                <button 
                  onClick={() => setShowEndSetModal(false)}
                  style={{ ...buttonStyle('#64748b'), padding: '1rem' }}
                >
                  Cancel
                </button>
              </div>
            </Modal>

            {/* Toast */}
            <Toast show={toast.show} message={toast.message} />

            {/* End Session Modal */}
            <Modal show={showEndSessionModal} onClose={() => setShowEndSessionModal(false)}>
              <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.5rem', fontWeight: '700', color: '#1e293b' }}>End Session</h2>
              <p style={{ color: '#64748b', marginBottom: '1rem' }}>
                Do you want to save or discard the sets from this session?
              </p>
              <div style={{ background: '#f8fafc', padding: '1rem', borderRadius: '8px', marginBottom: '1.5rem' }}>
                <p style={{ color: '#1e293b', marginBottom: '0.5rem' }}><strong>Current Session:</strong></p>
                <p style={{ color: '#64748b', fontSize: '0.875rem' }}>Sets completed: <strong>{setHistory.length}</strong></p>
                <p style={{ color: '#64748b', fontSize: '0.875rem' }}>Table: <strong>{currentTable}</strong></p>
              </div>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                <button 
                  onClick={endSessionSave}
                  style={{ 
                    ...buttonStyle('#10b981'), 
                    padding: '1rem',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'flex-start'
                  }}
                >
                  <span style={{ fontWeight: '700', fontSize: '1rem' }}>Save & Reset View</span>
                  <span style={{ fontSize: '0.75rem', opacity: 0.9, marginTop: '0.25rem' }}>Keep all sets in database, reset table view</span>
                </button>
                <button 
                  onClick={endSessionDiscard}
                  style={{ 
                    ...buttonStyle('#ef4444'), 
                    padding: '1rem',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'flex-start'
                  }}
                >
                  <span style={{ fontWeight: '700', fontSize: '1rem' }}>Discard Sets</span>
                  <span style={{ fontSize: '0.75rem', opacity: 0.9, marginTop: '0.25rem' }}>Delete all sets from database permanently</span>
                </button>
                <button 
                  onClick={() => setShowEndSessionModal(false)} 
                  style={{ ...buttonStyle('#64748b'), padding: '1rem' }}
                >
                  Cancel
                </button>
              </div>
            </Modal>
          </div>
        );
      }

      // Render the app
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<PitchGameTracker />);
    </script>
</body>
</html>
